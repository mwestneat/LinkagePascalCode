program HyoidModel;uses fileio, declareInterfaces, declareToolsPlus;const	con = 0.017453;	var	DrawWindow: WindowPtr;	myDialog: DialogPtr;	errnum:real;	spec: array[1..50] of string[8];	c1, c2, c3, c4, c5, c6, c7, c8: array[1..50] of char;	pect, hmncr, hyoid, ush, ushn, diag, diagn, diagnn, namereal: array[1..50] of real;  	iopdist, ljlev, sh, fishnum: array[1..50] of real;  	shdiag, hyodiag, ncrpect, diagpect, hyuro, hmdiag: array[1..50] of real;  	angushpect: array[1..50] of real;  	xshpect, yshpect, xncrpect, yncrpect: array[1..50] of real;  	xhyuro, yhyuro, xhmhyo, yhmhyo: array[1..50] of real;  	shdiagn, hyodiagn, ncrpectn, diagpectn, hyuron, hmdiagn: array[1..50] of real;  	angushpectn, angushpectnn: array[1..50] of real;  	tempanga, tempangb: array[1..50] of real;  	shdiagnn, hyodiagnn, ncrpectnn, diagpectnn, hyuronn, hmdiagnn: array[1..50] of real;  	uteang1, uteang2, uteang3, line: array[1..50] of real;  	xshpectn, yshpectn, xncrpectn, yncrpectn: array[1..50] of real;  	xhyuron, yhyuron, xhmhyon, yhmhyon: array[1..50] of real;  	xshpectnn, yshpectnn, xncrpectnn, yncrpectnn: array[1..50] of real;  	xhyuronn, yhyuronn, xhmhyonn, yhmhyonn: array[1..50] of real;  	cranel, cont, short, p: real;  	iopinput, ljrot, hyodep, hyorot, hyoft: array[1..50] of real;  	pectdraw, hmncrdraw, hyoiddraw, ushdraw, diagdraw: real;  	dxncrpectn, dyncrpectn, dxshpectn, dyshpectn, dxhyuron, dyhyuron, dxhmhyon, dyhmhyon: integer;  	shdraw: real;  	diagdrawn, diagdrawnn, ushdrawn: real;  	dxncrpect, dyncrpect, dxshpect, dyshpect, dxhyuro, dyhyuro, dxhmhyo, dyhmhyo: integer;  	tempdraw, draw1, draw2, draw3, draw4, draw5, draw6, draw7, draw8: integer;	a, b, c, d, ang, tempang1, tempang2, tempang3, tempang1n, tempang2n, tempang3n: real;		sidea, sideb, sidec, angab, angac, angbc, e: REAL;	gDrawState, i, fishcount, goodfile: INTEGER;	thefile, outfile: text;	{-------------Proc Declarations----------------}	Procedure InitVariables; Forward;	Procedure ProcessData; Forward;	Procedure ShowResults; Forward;	Procedure DrawClosed; Forward;	Procedure DrawOpen; Forward;	Procedure OpenFile; Forward;	Procedure HandleDialog; Forward;{------------------------------SaveData--------------------------------------------}procedure SaveData;		begin				writeln(outfile, fishnum[i]:4:0, spec[i]:10, cranel:4:0, cont:8:2, iopinput[i]:8:3, ljrot[i]:8:3, hyodep[i]:8:3, hyorot[i]:8:3, hyoft[i]:8:3);	writeln(outfile);	end;		{___________________________________________________________________________}	procedure SetDString (TheDialog: DialogPtr; item: integer; str: str255);		var			ItemType: integer;			ItemBox: rect;			ItemHdl: handle;	begin		GetDialogItem(TheDialog, item, ItemType, ItemHdl, ItemBox);		SetDialogItemText(ItemHdl, str)	end; 	function GetDString (TheDialog: DialogPtr; item: integer): str255;		var			ItemType: integer;			ItemBox: rect;			ItemHdl: handle;			str: str255;	begin		GetDialogItem(TheDialog, item, ItemType, ItemHdl, ItemBox);		GetDialogItemText(ItemHdl, str);		GetDString := str;	end;	procedure RealToString (Val: extended; width, fwidth: integer; var Str: Str255);  {Does number to string conversion equivalent to write(val:width:fwidth).}  var	begin		if width<1 then width:=1;		if (fwidth<0) or (fwidth>8) then fwidth:=0;		str:=StringOf(val:width:fwidth);	end;		procedure SetDReal (MyDialog: DialogPtr; item: integer; n: extended; fwidth: integer);		var			ItemType: integer;			ItemBox: rect;			ItemHdl: handle;			str: str255;	begin		GetDialogItem(MyDialog, item, ItemType, ItemHdl, ItemBox);		RealToString(n, 1, fwidth, str);		SetDialogItemText(ItemHdl, str)	end;	function StringToReal (str: str255): extended;		var			k, ndigits, StringLength: integer;			c: char;			n, m: extended;			negative, LeftOfPoint, NegExp: boolean;			exponent: LongInt;	begin		negative := false;		n := 0.0;		LeftOfPoint := true;		m := 0.1;		ndigits := 0;		StringLength := length(str);		k := 0;		repeat			k := k + 1;		until (str[k] in ['0'..'9', '-', '.']) or (k >= StringLength);		c := str[k];		repeat			if c = '-' then				negative := true			else if c = '.' then				LeftOfPoint := false			else if (c >= '0') and (c <= '9') then begin					ndigits := ndigits + 1;					if LeftOfPoint then						n := n * 10.0 + ord(c) - ord('0')					else begin							n := n + (ord(c) - ord('0')) * m;							m := m * 0.1;						end;				end;			k := k + 1;			if k <= StringLength then				c := str[k];		until not (c in ['0'..'9', '-', '.']) or (k > StringLength);		if (c = 'e') or (c = 'E') then begin				NegExp := false;				exponent := 0;				k := k + 1;				if k <= StringLength then					c := str[k];				if (c = '+') or (c = '-') then begin						if c = '-' then							NegExp := true;						k := k + 1;						if k <= StringLength then							c := str[k];					end;				repeat					if (c >= '0') and (c <= '9') then						exponent := exponent * 10 + ord(c) - ord('0');					k := k + 1;					if k <= StringLength then						c := str[k];				until not (c in ['0'..'9']) or (k > StringLength);				if negExp then					exponent := -exponent;				if exponent <> 0 then					n := n * exp(exponent * ln(10));			end; {if c='e'}		if ndigits = 0 then			n := 0  {was called BadReal}		else if negative then			n := -n;		StringToReal := n;	end;		function GetDReal (TheDialog: DialogPtr; item: integer): extended;		var			str: str255;	begin		str := GetDString(TheDialog, item);		GetDReal := StringToReal(str);	end;	{-------------------------------ShowResults---------------------------------------------}	procedure ShowResults;		const			SpecimenID = 17;			FishID = 3;			CranElID = 5;			SHID = 7;			HyoDepID = 9;			LJrotID = 11;			HyoRotID = 13;			HyoFTID = 16;			OKID = 14;				var			resDialog: DialogPtr;			item: integer;			dummy: real;			dumber: string[8];		begin				resDialog := GetNewDialog(401, nil, pointer(-1));				ShowWindow(resDialog);				SetDReal(resDialog, FishID, fishnum[i], 2);				SetDReal(resDialog, CranElID, cranel, 2);				SetDReal(resDialog,SHID, cont, 4);				SetDReal(resDialog,HyoRotID, hyorot[i], 2);				SetDReal(resDialog,HyoDepID, hyodep[i], 2);				SetDReal(resDialog,LJrotID, ljrot[i], 2);				SetDReal(resDialog,HyoFTID, hyoft[i], 2);				SetDString(resDialog, SpecimenID, spec[i]);												setport(resDialog);				repeat				ModalDialog(nil, item);				if item = SpecimenID then						dumber := GetDString(myDialog, SpecimenID);				if item = FishID then						dummy := GetDReal(myDialog, FishID);				if item = CranElID then						dummy := GetDReal(myDialog, CranElID);				if item = SHID then						dummy := GetDReal(myDialog, SHID);				if item = HyoRotID then						dummy := GetDReal(myDialog, HyoRotID);				if item = HyoDepID then						dummy := GetDReal(myDialog, HyoDepID);				if item = LJrotID then						dummy := GetDReal(myDialog, LJrotID);				if item = HyoFTID then						dummy := GetDReal(myDialog, HyoFTID);				until (item = OKID);				disposeDialog(resDialog);				setport(myDialog);		end;				{-------------------------------ShowError---------------------------------------------}	procedure ShowError;		const			OKID = 2;			ErrID =3;		var			errDialog: DialogPtr;			item: integer;			dummy:real;		begin		if errnum = 1 then errDialog := GetNewDialog(403, nil, pointer(-1));		if errnum = 2 then errDialog := GetNewDialog(404, nil, pointer(-1));		if errnum = 3 then errDialog := GetNewDialog(405, nil, pointer(-1));		if errnum = 4 then errDialog := GetNewDialog(406, nil, pointer(-1));		if errnum = 5 then errDialog := GetNewDialog(407, nil, pointer(-1));		if errnum = 6 then errDialog := GetNewDialog(408, nil, pointer(-1));		if errnum = 7 then errDialog := GetNewDialog(409, nil, pointer(-1));		if errnum = 8 then errDialog := GetNewDialog(410, nil, pointer(-1));						ShowWindow(errDialog);				setport(errDialog);				repeat				ModalDialog(nil, item);				until (item = OKID);				disposeDialog(errDialog);				setport(myDialog);		end;{-------------------------------TriangleCalc---------------------------------------------}	procedure TriangleCalc;		var			check1, check2, check3: integer;			a, b, c, d, ang: real;	begin		if sidea > (sideb + sidec) then			ShowError;		if sideb > (sidea + sidec) then			ShowError;		if sidec > (sideb + sidea) then			ShowError;		check1 := 0;		check2 := 0;		check3 := 0;		if sqr(sidea) < (sqr(sideb) + sqr(sidec)) then			begin				a := sqr(sideb) + sqr(sidec) - sqr(sidea);				b := 2 * sideb * sidec;				ang := a / b;				c := 1 - sqr(ang);				angbc := arctan(sqrt(c) / ang) / (con);				check1 := 1;			end;		if sqr(sideb) < (sqr(sidea) + sqr(sidec)) then			begin				a := sqr(sidea) + sqr(sidec) - sqr(sideb);				b := 2 * sidea * sidec;				ang := a / b;				c := 1 - sqr(ang);				angac := arctan(sqrt(c) / ang) / (con);				check2 := 1;			end;		if sqr(sidec) < (sqr(sidea) + sqr(sideb)) then			begin				a := sqr(sidea) + sqr(sideb) - sqr(sidec);				b := 2 * sidea * sideb;				ang := a / b;				c := 1 - sqr(ang);				angab := arctan(sqrt(c) / ang) / (con);				check3 := 1;			end;		if (check1 = 1) and (check2 = 1) then			angab := 180 - (angbc + angac);		if (check1 = 1) and (check3 = 1) then			angac := 180 - (angab + angbc);		if (check2 = 1) and (check3 = 1) then			angbc := 180 - (angab + angac);	end;{-------------------------------Process Data---------------------------------------------}procedure ProcessData;		begin{CALC ANG SH/DIAG, HYO/URO, and HYO/DIAG} 		sidea:=hyoid[i];		sideb:=ush[i];		sidec:=diag[i];		errnum:=1;		trianglecalc;		hyuro[i] := angab;		hyodiag[i] := angac;		shdiag[i] := angbc;		{CALC ANG NCR/PECT, DIAG/PECT, & HM/DIAG}				sidea:=diag[i];		sideb:=hmncr[i];		sidec:=pect[i];		errnum:=2;		trianglecalc;		hmdiag[i] := angab;		diagpect[i] := angac;		ncrpect[i] := angbc;		{CALC INITIAL COORDINATES OF LINKAGE}  		xshpect[i] := 0;  		yshpect[i] := 0;  		xncrpect[i] := pect[i];  		yncrpect[i] := 0;  		angushpect[i] := shdiag[i] + diagpect[i];  		xhyuro[i] := ush[i] * cos(angushpect[i] * con);  		yhyuro[i] := ush[i] * sin(angushpect[i] * con);  		xhmhyo[i] := diag[i] * cos(diagpect[i] * con);  		yhmhyo[i] := diag[i] * sin(diagpect[i] * con);  		{CALC SH SHORTENING}	if cont>0 then short := cont * ush[i];	if cont=0 then short := 0;{CALC NEW LENGTH OF U-SH LINK}    ushn[i] := ush[i] - short;    {CALC NEW DIAGONAL}    angushpect[i] := shdiag[i] + diagpect[i];    xhyuron[i] := cos(angushpect[i] * con) * ushn[i];    yhyuron[i] := sin(angushpect[i] * con) * ushn[i];    {Calc distance between hyuron and ncrpect}    p := sqr(xhyuron[i] - xncrpect[i]) + sqr(yhyuron[i] - yncrpect[i]);    line[i] := sqrt(p);    {CALC UTEANG1}	sidea:=ushn[i];	sideb:=line[i];	sidec:=pect[i];	errnum:=3;	trianglecalc;	tempangb[i] := angab;	tempanga[i] := angac;	uteang1[i] := angbc;	{CALC UTEANG2}	sidea:=hyoid[i];	sideb:=line[i];	sidec:=hmncr[i];	errnum:=4;	trianglecalc;	tempangb[i] := angab;	tempanga[i] := angac;	uteang2[i] := angbc;	{CALC UTEANG3}    uteang3[i] := abs(uteang1[i] - uteang2[i]);    e := sqr(pect[i]) + sqr(hmncr[i]) - 2 * pect[i] * hmncr[i] * cos(uteang3[i] * con);    diagn[i] := sqrt(e);     {CALC NEW ANG SH/DIAG, HYO/URO, and HYO/DIAG}	sidea:=hyoid[i];	sideb:=ushn[i];	sidec:=diagn[i];	errnum:=5;	trianglecalc;	hyuron[i] := angab;	hyodiagn[i] := angac;	shdiagn[i] := angbc;	{CALC NEW ANG NCR/PECT, DIAG/PECT, & HM/DIAG}	sidea:=diagn[i];	sideb:=hmncr[i];	sidec:=pect[i];	errnum:=6;	trianglecalc;	hmdiagn[i] := angab;	diagpectn[i] := angac;	ncrpectn[i] := angbc;	{CALC NEW COORDINATES OF LINKAGE}    xshpectn[i] := 0;    yshpectn[i] := 0;    xncrpectn[i] := pect[i];    yncrpectn[i] := 0;    angushpectn[i] := shdiagn[i] + diagpectn[i];    xhyuron[i] := ushn[i] * cos(angushpectn[i] * con);    yhyuron[i] := ushn[i] * sin(angushpectn[i] * con);    xhmhyon[i] := diagn[i] * cos(diagpectn[i] * con);    yhmhyon[i] := diagn[i] * sin(diagpectn[i] * con);    {CALC 2ND NEW NCR/PECT}    ncrpectnn[i] := ncrpectn[i] + cranel;{CALC 2ND NEW DIAGONAL}    e := sqr(pect[i]) + sqr(hmncr[i]) - 2 * pect[i] * hmncr[i] * cos(ncrpectnn[i] * con);    diagnn[i] := sqrt(e);{CALC 2ND NEW ANG SH/DIAG, HYO/URO, and HYO/DIAG}	sidea:=hyoid[i];	sideb:=ushn[i];	sidec:=diagnn[i];	errnum:=7;	trianglecalc;	hyuronn[i] := angab;	hyodiagnn[i] := angac;	shdiagnn[i] := angbc;	{CALC 2ND NEW ANG NCR/PECT, DIAG/PECT, & HM/DIAG}	sidea:=diagnn[i];	sideb:=hmncr[i];	sidec:=pect[i];	errnum:=8;	trianglecalc;	hmdiagnn[i] := angab;	diagpectnn[i] := angac;	ncrpectnn[i] := angbc;	{CALC 2ND NEW COORDINATES OF LINKAGE}    xshpectnn[i] := 0;    yshpectnn[i] := 0;    xncrpectnn[i] := pect[i];    yncrpectnn[i] := 0;    angushpectnn[i] := shdiagnn[i] + diagpectnn[i];    xhyuronn[i] := ushn[i] * cos(angushpectnn[i] * con);    yhyuronn[i] := ushn[i] * sin(angushpectnn[i] * con);    xhmhyonn[i] := diagnn[i] * cos(diagpectnn[i] * con);    yhmhyonn[i] := diagnn[i] * sin(diagpectnn[i] * con);{CALC DISTANCE MOVED BY IOP/HYO JOINT}    iopinput[i] := abs(yhmhyo[i] - yhmhyonn[i]);    {CALC LOWER JAW ROTATION}    a := sqr(ljlev[i]) + sqr(iopinput[i]) - sqr(ljlev[i]);    b := 2 * ljlev[i] * iopinput[i];    ang := a / b;    c := 1 - sqr(ang);    ljrot[i] := 180 - 2 * arctan(sqrt(c) / ang) / (con);{CALC HYOID DEPRESSION}    hyodep[i] := xhyuro[i] - xhyuronn[i];    hyorot[i] := abs((hmdiag[i] + hyodiag[i]) - (hmdiagnn[i] + hyodiagnn[i]));{CALC HYOID FORCE TRANSMISSION COEFFICIENT}    hyoft[i] := cranel / hyorot[i];        {CALC VARS FOR DRAWING}    pectdraw := pect[i];    hmncrdraw := hmncr[i];    hyoiddraw := hyoid[i];    ushdraw := ush[i];    diagdraw := diag[i];    shdraw := sh[i];    ushdrawn := ushn[i];    diagdrawn := diagn[i];    diagdrawnn := diagnn[i];	if (pectdraw < 200) then		repeat			pectdraw := pectdraw * 1.1;			hmncrdraw := hmncrdraw * 1.1;			hyoiddraw := hyoiddraw * 1.1;			ushdraw := ushdraw * 1.1;			diagdraw := diagdraw * 1.1;			shdraw := shdraw * 1.1;			diagdrawn := diagdrawn * 1.1;			ushdrawn := ushdrawn * 1.1;			diagdrawnn := diagdrawnn * 1.1;		until (pectdraw > 200);				if (pectdraw > 200) then		repeat			pectdraw := pectdraw * 0.9;			hmncrdraw := hmncrdraw * 0.9;			hyoiddraw := hyoiddraw * 0.9;			ushdraw := ushdraw * 0.9;			diagdraw := diagdraw * 0.9;			shdraw := shdraw * 0.9;			diagdrawn := diagdrawn * 0.9;			ushdrawn := ushdrawn * 0.9;			diagdrawnn := diagdrawnn * 0.9;		until (pectdraw < 200);		    end;{-----------------------------DRAWCLOSED-------------------------------}procedure DrawClosed;			begin		gDrawState:= 1;	{Set draw coordinates}    dxncrpect := 100;    dyncrpect := 100;    dxshpect := 100;        	tempdraw:=1;		repeat			tempdraw:= tempdraw+1;		until tempdraw >= pectdraw;	dyshpect := 100 + tempdraw;		    tempdraw:=1;		repeat			tempdraw:= tempdraw+1;		until tempdraw >= (ushdraw * sin(angushpect[i] * con));    dxhyuro := dxshpect + tempdraw;        	tempdraw:=1;		repeat			tempdraw:= tempdraw+1;		until tempdraw >= (ushdraw * cos(angushpect[i] * con));    dyhyuro := dyshpect - tempdraw;                tempdraw:=1;		repeat			tempdraw:= tempdraw+1;		until tempdraw >= (diagdraw * sin(diagpect[i] * con));    dxhmhyo := dxshpect + tempdraw;            tempdraw:=1;		repeat			tempdraw:= tempdraw+1;		until tempdraw >= (diagdraw * cos(diagpect[i] * con));    dyhmhyo := dyshpect - tempdraw;							setPort(DrawWindow);			pensize(2, 2);			MoveTo(dxncrpect, dyncrpect);   	 		LineTo(dxshpect, dyshpect);    		LineTo(dxhyuro, dyhyuro);    		LineTo(dxhmhyo, dyhmhyo);    		LineTo(dxncrpect, dyncrpect);		end;{-----------------------------DRAWOPEN-------------------------------}Procedure DrawOpen;	begin			gDrawState:= 2;			dxncrpectn := 100;      		dyncrpectn := 100;      		dxshpectn := 100;      		      		tempdraw:=1;			repeat				tempdraw:= tempdraw+1;			until tempdraw >= pectdraw;			dyshpectn := 100 + tempdraw;		    	tempdraw:=1;			repeat				tempdraw:= tempdraw+1;			until tempdraw >= (ushdrawn * sin(angushpectnn[i] * con));    		dxhyuron := dxshpectn + tempdraw;        		tempdraw:=1;			repeat				tempdraw:= tempdraw+1;			until tempdraw >= (ushdrawn * cos(angushpectnn[i] * con));    		dyhyuron := dyshpectn - tempdraw;                	tempdraw:=1;			repeat				tempdraw:= tempdraw+1;			until tempdraw >= (diagdrawnn * sin(diagpectnn[i] * con));    		dxhmhyon := dxshpectn + tempdraw;            	tempdraw:=1;			repeat				tempdraw:= tempdraw+1;			until tempdraw >= (diagdrawnn * cos(diagpectnn[i] * con));    		dyhmhyon := dyshpectn - tempdraw;					setPort(DrawWindow);			pensize(1, 1);			MoveTo(dxncrpectn, dyncrpectn);       		LineTo(dxshpectn, dyshpectn);       		LineTo(dxhyuron, dyhyuron);       		LineTo(dxhmhyon, dyhmhyon);       		LineTo(dxncrpectn, dyncrpectn);	end;		{-----------------------------Magnify-------------------------------}Procedure Magnify;		begin					pectdraw := pectdraw * 1.1;					hmncrdraw := hmncrdraw * 1.1;					hyoiddraw := hyoiddraw * 1.1;					ushdraw := ushdraw * 1.1;					diagdraw := diagdraw * 1.1;					shdraw := shdraw * 1.1;					diagdrawn := diagdrawn * 1.1;					ushdrawn := ushdrawn * 1.1;					diagdrawnn := diagdrawnn * 1.1;					if GDrawState=1 then 						DrawClosed;					if GDrawState=2 then 						DrawOpen;			end;		{-----------------------------Reduce-------------------------------}Procedure Reduce;		begin					pectdraw := pectdraw * 0.9;					hmncrdraw := hmncrdraw * 0.9;					hyoiddraw := hyoiddraw * 0.9;					ushdraw := ushdraw * 0.9;					diagdraw := diagdraw * 0.9;					shdraw := shdraw * 0.9;					diagdrawn := diagdrawn * 0.9;					ushdrawn := ushdrawn * 0.9;					diagdrawnn := diagdrawnn * 0.9;					if GDrawState=1 then 						DrawClosed;					if GDrawState=2 then 						DrawOpen;		end;{---------------------------------HandleDialog------------------------------------}		procedure HandleDialog;		const			SpecimenID =35;			CranElID = 2;			SHcontID = 4;			PectID = 6;			HmNcrID = 8;			HyoidID = 10;			USHID = 12;			DiagID = 14;			SHID = 16;			LJID = 18;				AnalyzeID = 19;			DclosedID = 20;			DopenID = 21;			ResultsID = 22;			SaveID = 23;			QuitID = 24;			NextFishID = 25;			PrevFishID = 28;			FishnumID = 26;			OpenID = 29;			SimulateID = 30;			MagnifyID = 31;			ReduceID = 32;				var			myDialog: DialogPtr;			item: integer;					begin				myDialog := GetNewDialog(400, nil, pointer(-1));				ShowWindow(myDialog);				SetDReal(myDialog, CranElID, cranel, 2);				SetDReal(myDialog, SHcontID, cont, 4);				SetDReal(myDialog, PectID, pect[i], 2);				SetDReal(myDialog, HmNcrID, hmncr[i], 2);				SetDReal(myDialog, HyoidID, hyoid[i], 2);				SetDReal(myDialog, USHID, ush[i], 2);				SetDReal(myDialog, DiagID, diag[i], 2);				SetDReal(myDialog, SHID, sh[i], 2);				SetDReal(myDialog, LJID, ljlev[i], 2);				SetDReal(myDialog, FishnumID, fishnum[i], 2);				SetDString(myDialog, SpecimenID, spec[i]);				setport(myDialog);				repeat					ModalDialog(nil, item);					if item = CranElID then						cranel := GetDReal(myDialog, CranElID);					if item = SHcontID then						cont := GetDReal(myDialog, SHcontID);					if item = PectID then						pect[i] := GetDReal(myDialog, PectID);					if item = HmNcrID then						hmncr[i] := GetDReal(myDialog, HmNcrID);					if item = HyoidID then						hyoid[i] := GetDReal(myDialog, HyoidID);					if item = USHID then						ush[i] := GetDReal(myDialog, USHID);					if item = DiagID then						diag[i] := GetDReal(myDialog, DiagID);					if item = SHID then						sh[i] := GetDReal(myDialog, SHID);					if item = FishNumID then						fishnum[i] := GetDReal(myDialog, FishNumID);											if item = OpenID then 						begin							OpenFile;							DisposeDialog(myDialog);							i:=1;							HandleDialog;						end;					if item = AnalyzeID then ProcessData;					if item = ResultsID then ShowResults;					if item = DclosedID then DrawClosed;					if item = DopenID then DrawOpen;					if item = MagnifyID then 						begin							DisposeDialog(myDialog);							DisposeWindow (DrawWindow);							DrawWindow := GetNewWindow(128, nil, WindowPtr(-1));							Magnify;							HandleDialog;						end;					if item = ReduceID then						begin							DisposeDialog(myDialog);							DisposeWindow (DrawWindow);							DrawWindow := GetNewWindow(128, nil, WindowPtr(-1));			 				Reduce;			 				HandleDialog;						end;					if item = SaveID then SaveData;					if item = NextFishID then						begin							if (i<fishcount) then							begin							DisposeDialog(myDialog);							i:= i+1;							HandleDialog;							end;						end;					if item = PrevFishID then						begin							if (i>1) then							begin							DisposeDialog(myDialog);							i:= i-1;							HandleDialog;							end;						end;					if item = SimulateID then						begin													cranel:=0;							cont:=0;							while cranel < 30 do							begin								cranel:= cranel+1;								ProcessData;								SaveData;							end;														cranel:=0;							cont:=0;							while cont < 0.1 do							begin								cont:= cont+0.01;								ProcessData;								SaveData;							end;														cranel:=0;							cont:=0;							while cranel < 30 do							begin								cranel:= cranel+1;								cont:=cont+0.01;								ProcessData;								SaveData;							end;						end;										until (item = QuitID);				DisposeDialog(myDialog);				DisposeWindow(DrawWindow);				close(outfile);		end;			{---------------------------------DoOpenFile--------------------------------------------}Procedure OpenFile;  var    theReply: StandardFileReply;   outReply: sfReply;   begin	GetFileName(theReply);	if theReply.sfgood then	begin		Open(thefile, Concat(GetFullPathStr(theReply.sfFile), theReply.sfFile.name));		i := 0;		while not eof(thefile) do			begin				i:=i+1;				fishcount:=i;				fishnum[i]:=i;				readln(thefile, c1[i], c2[i], c3[i], c4[i], c5[i], c6[i], c7[i], c8[i], pect[i], hmncr[i], hyoid[i], ush[i], diag[i], sh[i], ljlev[i]);				spec[i]:= c1[i]+c2[i]+c3[i]+c4[i]+c5[i]+c6[i]+c7[i]+c8[i];			end;	end;	close(thefile);	outReply.fname := concat(theReply.sfFile.name, '.xls');	rewrite(outfile, outReply.fname);	writeln(outfile, 'Fishnum Specimen CranEl SHcontrac IOPdist LJrot HyoDep HyoRot HyoFT'); end;{-----------------------------------Main Loop----------------} procedure MainLoop; var	 	h: integer;												done:boolean; begin 	done := false; 	CranEl:=10;	cont:=0.1;	DrawWindow := GetNewWindow(128, nil, WindowPtr(-1));  	while not done do		begin			HandleDialog;		end;		done:=true; end;{Program JawsModel}begin	InitGraf(@qd.thePort);	InitFonts;	InitWindows;	InitMenus;	TEInit;	InitDialogs(nil);	if InitToolsPlus(100, 13, initTE32KBuffer, initUseColor) then		begin;			MainLoop;		end;end.